#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Parse the episodes.md file to extract all episode data
function parseEpisodesIndex() {
  const indexPath = path.join(__dirname, '../index/episodes.md');
  const content = fs.readFileSync(indexPath, 'utf-8');

  const episodes = [];
  const lines = content.split('\n');

  let inTable = false;
  for (const line of lines) {
    // Start reading table rows after the header
    if (line.startsWith('|----')) {
      inTable = true;
      continue;
    }

    if (!inTable || !line.startsWith('|')) continue;

    // Parse table row: | [Guest](link) | Summary | Keywords |
    const cells = line.split('|').map(c => c.trim()).filter(Boolean);
    if (cells.length !== 3) continue;

    // Extract guest name and slug from markdown link
    const guestMatch = cells[0].match(/\[([^\]]+)\]\(\.\.\/episodes\/([^\/]+)\/transcript\.md\)/);
    if (!guestMatch) continue;

    const guest = guestMatch[1];
    const slug = guestMatch[2];
    const summary = cells[1].trim();
    const keywords = cells[2]
      .split(',')
      .map(k => k.trim())
      .filter(Boolean);

    // Skip empty entries
    if (!summary || summary.length < 10) continue;

    episodes.push({
      guest,
      slug,
      summary,
      keywords
    });
  }

  return episodes;
}

// Generate the TypeScript file
function generateTypeScriptFile(episodes) {
  const ts = `// Episode data extracted from index/episodes.md
// Auto-generated by scripts/generate-episodes-data.js
// DO NOT EDIT MANUALLY

export interface Episode {
  guest: string;
  slug: string;
  summary: string;
  keywords: string[];
  publishDate?: string;
  duration?: string;
  viewCount?: number;
  youtubeUrl?: string;
}

export const allEpisodes: Episode[] = ${JSON.stringify(episodes, null, 2)};

// Get all unique keywords across all episodes
export function getAllKeywords(): string[] {
  const keywordSet = new Set<string>();
  allEpisodes.forEach(ep => {
    ep.keywords.forEach(kw => keywordSet.add(kw));
  });
  return Array.from(keywordSet).sort();
}

// Search episodes by query (searches guest, summary, keywords)
export function searchEpisodes(query: string, selectedKeywords: string[] = []): Episode[] {
  const lowerQuery = query.toLowerCase().trim();

  return allEpisodes.filter(episode => {
    // Filter by selected keywords first
    if (selectedKeywords.length > 0) {
      const hasKeyword = selectedKeywords.some(kw =>
        episode.keywords.some(epKw => epKw.toLowerCase() === kw.toLowerCase())
      );
      if (!hasKeyword) return false;
    }

    // Then filter by search query
    if (!lowerQuery) return true;

    return (
      episode.guest.toLowerCase().includes(lowerQuery) ||
      episode.summary.toLowerCase().includes(lowerQuery) ||
      episode.keywords.some(kw => kw.toLowerCase().includes(lowerQuery))
    );
  });
}

// Sort episodes
export type SortOption = 'date-desc' | 'date-asc' | 'views-desc' | 'guest-asc';

export function sortEpisodes(episodes: Episode[], sortBy: SortOption): Episode[] {
  const sorted = [...episodes];

  switch (sortBy) {
    case 'date-desc':
      return sorted.sort((a, b) => {
        if (!a.publishDate || !b.publishDate) return 0;
        return new Date(b.publishDate).getTime() - new Date(a.publishDate).getTime();
      });
    case 'date-asc':
      return sorted.sort((a, b) => {
        if (!a.publishDate || !b.publishDate) return 0;
        return new Date(a.publishDate).getTime() - new Date(b.publishDate).getTime();
      });
    case 'views-desc':
      return sorted.sort((a, b) => (b.viewCount || 0) - (a.viewCount || 0));
    case 'guest-asc':
      return sorted.sort((a, b) => a.guest.localeCompare(b.guest));
    default:
      return sorted;
  }
}
`;

  const outputPath = path.join(__dirname, '../lib/episodesData.ts');
  fs.writeFileSync(outputPath, ts, 'utf-8');

  return outputPath;
}

// Main execution
try {
  console.log('Parsing episodes index...');
  const episodes = parseEpisodesIndex();
  console.log(`Found ${episodes.length} episodes`);

  console.log('Generating TypeScript file...');
  const outputPath = generateTypeScriptFile(episodes);
  console.log(`‚úÖ Generated ${outputPath}`);
  console.log(`üìä Total episodes: ${episodes.length}`);

  // Count unique keywords
  const allKeywords = new Set();
  episodes.forEach(ep => ep.keywords.forEach(kw => allKeywords.add(kw)));
  console.log(`üè∑Ô∏è  Unique topics: ${allKeywords.size}`);

} catch (error) {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
}
